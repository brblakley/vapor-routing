{"kind":"symbol","topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/DebugInboundEventsHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/DebugOutboundEventsHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldPrepender","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOPCAPRingBuffer","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/RequestResponseHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/ServerQuiescingHelper"],"title":"Classes"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOExtrasError"],"title":"Protocols"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOLengthFieldBitLength"],"title":"Structures"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldPrependerError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOExtrasErrors","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOLengthFieldBasedFrameDecoderError"],"title":"Enumerations"}],"metadata":{"role":"collection","symbolKind":"module","externalID":"NIOExtras","title":"NIOExtras","roleHeading":"Framework","modules":[{"name":"NIOExtras"}]},"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras","interfaceLanguage":"swift"},"sections":[],"hierarchy":{"paths":[[]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/nioextras"]}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOJSONRPCFraming":{"role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOJSONRPCFraming","kind":"identifier"}],"title":"NIOJSONRPCFraming","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming","navigatorTitle":[{"text":"NIOJSONRPCFraming","kind":"identifier"}],"url":"\/documentation\/nioextras\/niojsonrpcframing","kind":"symbol","abstract":[{"type":"text","text":"Namespace to contain JSON framing implementation."}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LineBasedFrameDecoder":{"type":"topic","url":"\/documentation\/nioextras\/linebasedframedecoder","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LineBasedFrameDecoder"}],"abstract":[{"type":"text","text":"A decoder that splits incoming "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":"s around line end"},{"text":" ","type":"text"},{"text":"character(s) (","type":"text"},{"code":"'\\n'","type":"codeVoice"},{"type":"text","text":" or "},{"type":"codeVoice","code":"'\\r\\n'"},{"type":"text","text":")."}],"navigatorTitle":[{"kind":"identifier","text":"LineBasedFrameDecoder"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","title":"LineBasedFrameDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOExtrasErrors":{"type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOExtrasErrors"}],"navigatorTitle":[{"kind":"identifier","text":"NIOExtrasErrors"}],"abstract":[{"type":"text","text":"Errors that are raised in NIOExtras."}],"title":"NIOExtrasErrors","kind":"symbol","url":"\/documentation\/nioextras\/nioextraserrors","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOExtrasErrors"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/DebugInboundEventsHandler":{"kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DebugInboundEventsHandler"}],"abstract":[{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that prints all inbound events that pass through the pipeline by default,"},{"type":"text","text":" "},{"type":"text","text":"overridable by providing your own closure for custom logging. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/DebugOutboundEventsHandler"},{"type":"text","text":" for outbound events."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DebugInboundEventsHandler"}],"url":"\/documentation\/nioextras\/debuginboundeventshandler","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/DebugInboundEventsHandler","title":"DebugInboundEventsHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/RequestResponseHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/RequestResponseHandler","url":"\/documentation\/nioextras\/requestresponsehandler","type":"topic","kind":"symbol","role":"symbol","title":"RequestResponseHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RequestResponseHandler","kind":"identifier"}],"abstract":[{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/RequestResponseHandler","isActive":true},{"type":"text","text":" receives a "},{"type":"codeVoice","code":"Request"},{"type":"text","text":" alongside an "},{"type":"codeVoice","code":"EventLoopPromise<Response>"},{"type":"text","text":" from the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"‘s"},{"type":"text","text":" "},{"type":"text","text":"outbound side. It will fulfill the promise with the "},{"type":"codeVoice","code":"Response"},{"type":"text","text":" once it’s received from the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"’s inbound"},{"type":"text","text":" "},{"type":"text","text":"side."}],"navigatorTitle":[{"text":"RequestResponseHandler","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/FixedLengthFrameDecoder":{"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","navigatorTitle":[{"text":"FixedLengthFrameDecoder","kind":"identifier"}],"url":"\/documentation\/nioextras\/fixedlengthframedecoder","title":"FixedLengthFrameDecoder","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"FixedLengthFrameDecoder","kind":"identifier"}],"abstract":[{"type":"text","text":"A decoder that splits the received "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" by a fixed number"},{"type":"text","text":" "},{"type":"text","text":"of bytes. For example, if you received the following four fragmented packets:"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOExtrasError":{"kind":"symbol","abstract":[{"type":"text","text":"Base type for errors from NIOExtras"}],"navigatorTitle":[{"text":"NIOExtrasError","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOExtrasError","url":"\/documentation\/nioextras\/nioextraserror","type":"topic","title":"NIOExtrasError","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOExtrasError","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOPCAPRingBuffer/addFragment(_:)":{"url":"\/documentation\/nioextras\/niopcapringbuffer\/addfragment(_:)","abstract":[{"type":"text","text":"Record a fragment into the buffer, making space if required."}],"type":"topic","title":"addFragment(_:)","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"addFragment","kind":"identifier"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","text":"ByteBuffer","kind":"typeIdentifier"},{"text":")","kind":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOPCAPRingBuffer\/addFragment(_:)","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOPCAPRingBuffer/emitPCAP()":{"url":"\/documentation\/nioextras\/niopcapringbuffer\/emitpcap()","abstract":[{"type":"text","text":"Emit the captured data to a consuming function; then clear the captured data."}],"type":"topic","title":"emitPCAP()","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"emitPCAP","kind":"identifier"},{"text":"() -> ","kind":"text"},{"preciseIdentifier":"s:7NIOCore14CircularBufferV","text":"CircularBuffer","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier","text":"ByteBuffer"},{"kind":"text","text":">"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOPCAPRingBuffer\/emitPCAP()","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldPrependerError":{"type":"topic","kind":"symbol","abstract":[{"type":"text","text":"Error types from "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldPrepender","isActive":true}],"title":"LengthFieldPrependerError","role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LengthFieldPrependerError","kind":"identifier"}],"navigatorTitle":[{"text":"LengthFieldPrependerError","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldPrependerError","url":"\/documentation\/nioextras\/lengthfieldprependererror"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOLengthFieldBitLength":{"role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOLengthFieldBitLength"}],"url":"\/documentation\/nioextras\/niolengthfieldbitlength","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOLengthFieldBitLength","abstract":[{"type":"text","text":"A struct to describe the length of a piece of data in bits"}],"title":"NIOLengthFieldBitLength","navigatorTitle":[{"kind":"identifier","text":"NIOLengthFieldBitLength"}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOLengthFieldBasedFrameDecoderError":{"role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOLengthFieldBasedFrameDecoderError","kind":"identifier"}],"url":"\/documentation\/nioextras\/niolengthfieldbasedframedecodererror","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOLengthFieldBasedFrameDecoderError","navigatorTitle":[{"text":"NIOLengthFieldBasedFrameDecoderError","kind":"identifier"}],"kind":"symbol","title":"NIOLengthFieldBasedFrameDecoderError","abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldBasedFrameDecoder":{"abstract":[{"text":"A decoder that splits the received ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" by the number of bytes specified in a fixed length header","type":"text"},{"text":" ","type":"text"},{"text":"contained within the buffer.","type":"text"}],"type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"title":"LengthFieldBasedFrameDecoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","navigatorTitle":[{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"url":"\/documentation\/nioextras\/lengthfieldbasedframedecoder","kind":"symbol","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldPrepender":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"LengthFieldPrepender"}],"title":"LengthFieldPrepender","url":"\/documentation\/nioextras\/lengthfieldprepender","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LengthFieldPrepender"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldPrepender","abstract":[{"type":"text","text":"An encoder that takes a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" message and prepends the number of bytes in the message."},{"type":"text","text":" "},{"type":"text","text":"The length field is always the same fixed length specified on construction."},{"type":"text","text":" "},{"type":"text","text":"These bytes contain a binary specification of the message size."}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras":{"role":"collection","url":"\/documentation\/nioextras","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras","kind":"symbol","title":"NIOExtras","abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOWritePCAPHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOWritePCAPHandler"}],"title":"NIOWritePCAPHandler","role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/nioextras\/niowritepcaphandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOWritePCAPHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that can write a ","type":"text"},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","isActive":true,"type":"reference"},{"text":" containing the send\/received","type":"text"},{"text":" ","type":"text"},{"text":"data as synthesized TCP packet captures.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOPCAPRingBuffer":{"url":"\/documentation\/nioextras\/niopcapringbuffer","abstract":[{"type":"text","text":"Storage for the most recent set of packets captured subject to constraints."},{"type":"text","text":" "},{"type":"text","text":"Use "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOPCAPRingBuffer\/addFragment(_:)","isActive":true},{"type":"text","text":" as the sink to a "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","isActive":true},{"type":"text","text":" and call "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOPCAPRingBuffer\/emitPCAP()","type":"reference","isActive":true},{"type":"text","text":" "},{"type":"text","text":"when you wish to get the recorded data."}],"type":"topic","title":"NIOPCAPRingBuffer","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPCAPRingBuffer"}],"navigatorTitle":[{"kind":"identifier","text":"NIOPCAPRingBuffer"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOPCAPRingBuffer","kind":"symbol"},"https://en.wikipedia.org/wiki/Pcap":{"url":"https:\/\/en.wikipedia.org\/wiki\/Pcap","identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","type":"link","title":".pcap file","titleInlineContent":[{"code":".pcap","type":"codeVoice"},{"text":" file","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/ServerQuiescingHelper":{"type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ServerQuiescingHelper"}],"navigatorTitle":[{"kind":"identifier","text":"ServerQuiescingHelper"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/ServerQuiescingHelper","url":"\/documentation\/nioextras\/serverquiescinghelper","abstract":[{"text":"Helper that can be used to orchestrate the quiescing of a server ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":" and all the child ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":"s that are","type":"text"},{"text":" ","type":"text"},{"text":"open at a given point in time.","type":"text"}],"title":"ServerQuiescingHelper"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/DebugOutboundEventsHandler":{"kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DebugOutboundEventsHandler"}],"abstract":[{"type":"text","text":"ChannelOutboundHandler that prints all outbound events that pass through the pipeline by default,"},{"type":"text","text":" "},{"type":"text","text":"overridable by providing your own closure for custom logging. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/DebugInboundEventsHandler"},{"type":"text","text":" for inbound events."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DebugOutboundEventsHandler"}],"url":"\/documentation\/nioextras\/debugoutboundeventshandler","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/DebugOutboundEventsHandler","title":"DebugOutboundEventsHandler"}}}