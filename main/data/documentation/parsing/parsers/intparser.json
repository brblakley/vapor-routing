{"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A parser that consumes an integer (with an optional leading "},{"type":"codeVoice","code":"+"},{"type":"text","text":" or "},{"type":"codeVoice","code":"-"},{"type":"text","text":" sign for signed integer"},{"type":"text","text":" "},{"type":"text","text":"types) from the beginning of a collection of UTF8 code units."}],"metadata":{"externalID":"s:7Parsing7ParsersO9IntParserV","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"IntParser"}],"modules":[{"name":"Parsing"}],"roleHeading":"Structure","symbolKind":"struct","title":"Parsers.IntParser","extendedModule":"Parsing","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IntParser"}]},"schemaVersion":{"minor":3,"major":0,"patch":0},"topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/init(radix:)"],"title":"Initializers"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/radix"],"title":"Instance Properties"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/parse(_:)"],"title":"Instance Methods"},{"generated":true,"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/Parser-Implementations","doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/ParserPrinter-Implementations"],"title":"Default Implementations"}],"relationshipsSections":[{"type":"conformsTo","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parser","doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/ParserPrinter"],"kind":"relationships","title":"Conforms To"}],"primaryContentSections":[{"declarations":[{"languages":["swift"],"platforms":["Linux"],"tokens":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"IntParser","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Input","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Output","kind":"genericParameter"},{"text":"> ","kind":"text"},{"text":"where","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":" : ","kind":"text"},{"text":"Collection","kind":"typeIdentifier","preciseIdentifier":"s:Sl"},{"text":", ","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":" == ","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"SubSequence","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":" : ","kind":"text"},{"text":"FixedWidthInteger","kind":"typeIdentifier","preciseIdentifier":"s:s17FixedWidthIntegerP"},{"text":", ","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Element","kind":"typeIdentifier"},{"text":" == ","kind":"text"},{"text":"UTF8","kind":"typeIdentifier","preciseIdentifier":"s:s4UTF8a"},{"text":".","kind":"text"},{"text":"CodeUnit","kind":"typeIdentifier","preciseIdentifier":"s:s7UnicodeO4UTF8O8CodeUnita"}]}],"kind":"declarations"},{"content":[{"text":"Overview","level":2,"anchor":"overview","type":"heading"},{"inlineContent":[{"type":"text","text":"You will not typically need to interact with this type directly. Instead you will usually use"},{"type":"text","text":" "},{"type":"text","text":"the static "},{"type":"codeVoice","code":"parser()"},{"type":"text","text":" method on the "},{"type":"codeVoice","code":"FixedWidthInteger"},{"type":"text","text":" of your choice, e.g. "},{"type":"codeVoice","code":"Int.parser()"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"UInt8.parser()"},{"type":"text","text":", etc., all of which construct this type."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"See "},{"type":"text","text":"doc:Int"},{"type":"text","text":" for more information about this parser."}],"type":"paragraph"}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/parsing\/parsers\/intparser"]}],"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing","doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers"]]},"sections":[],"kind":"symbol","references":{"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers/IntParser/ParserPrinter-Implementations":{"role":"collectionGroup","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/ParserPrinter-Implementations","abstract":[],"url":"\/documentation\/parsing\/parsers\/intparser\/parserprinter-implementations","title":"ParserPrinter Implementations","kind":"article"},"doc://co.pointfree.VaporRouting/documentation/Parsing/ParserPrinter":{"title":"ParserPrinter","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/ParserPrinter","url":"\/documentation\/parsing\/parserprinter","abstract":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parser"},{"type":"text","text":" that can incrementally “print” an output value back into an input."}],"role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParserPrinter"}],"type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ParserPrinter"}],"conformance":{"constraints":[{"type":"codeVoice","code":"Input"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"PrependableCollection"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"Input.SubSequence"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Output"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"FixedWidthInteger"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Input.Element"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"UTF8.CodeUnit"},{"text":".","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers/IntParser/radix":{"title":"radix","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/radix","url":"\/documentation\/parsing\/parsers\/intparser\/radix","abstract":[{"type":"text","text":"The radix, or base, to use for converting text to an integer value."}],"role":"symbol","fragments":[{"text":"let","kind":"keyword"},{"text":" ","kind":"text"},{"text":"radix","kind":"identifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"}],"type":"topic","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers":{"abstract":[{"text":"A namespace for types that serve as parsers.","type":"text"}],"title":"Parsers","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parsers","kind":"identifier"}],"url":"\/documentation\/parsing\/parsers","type":"topic","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Parsers","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers"},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers/IntParser":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser","url":"\/documentation\/parsing\/parsers\/intparser","kind":"symbol","role":"symbol","title":"Parsers.IntParser","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"IntParser"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"IntParser"}],"abstract":[{"text":"A parser that consumes an integer (with an optional leading ","type":"text"},{"code":"+","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"-","type":"codeVoice"},{"text":" sign for signed integer","type":"text"},{"text":" ","type":"text"},{"text":"types) from the beginning of a collection of UTF8 code units.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/Parsing":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing","type":"topic","kind":"symbol","url":"\/documentation\/parsing","abstract":[],"title":"Parsing","role":"collection"},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parser":{"abstract":[{"text":"Declares a type that can incrementally parse an ","type":"text"},{"code":"Output","type":"codeVoice"},{"text":" value from an ","type":"text"},{"code":"Input","type":"codeVoice"},{"text":" value.","type":"text"}],"title":"Parser","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Parser","kind":"identifier"}],"url":"\/documentation\/parsing\/parser","type":"topic","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Parser","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parser"},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers/IntParser/init(radix:)":{"title":"init(radix:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/init(radix:)","url":"\/documentation\/parsing\/parsers\/intparser\/init(radix:)","abstract":[],"role":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"(","kind":"text"},{"text":"radix","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":")"}],"type":"topic","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers/IntParser/parse(_:)":{"title":"parse(_:)","url":"\/documentation\/parsing\/parsers\/intparser\/parse(_:)","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/parse(_:)","type":"topic","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"parse","kind":"identifier"},{"text":"(","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Output","kind":"typeIdentifier"}],"abstract":[{"text":"Attempts to parse a nebulous piece of data into something more well-structured. Typically","type":"text"},{"text":" ","type":"text"},{"text":"you only call this from other ","type":"text"},{"code":"Parser","type":"codeVoice"},{"text":" conformances, not when you want to parse a concrete","type":"text"},{"text":" ","type":"text"},{"text":"input.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/Parsing/Parsers/IntParser/Parser-Implementations":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/Parsing\/Parsers\/IntParser\/Parser-Implementations","kind":"article","role":"collectionGroup","url":"\/documentation\/parsing\/parsers\/intparser\/parser-implementations","type":"topic","title":"Parser Implementations","abstract":[]}}}