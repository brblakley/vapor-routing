{"schemaVersion":{"major":0,"patch":0,"minor":3},"sections":[],"abstract":[{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is a ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that can be dynamically removed from a ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" whilst","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" is operating normally.","type":"text"},{"text":" ","type":"text"},{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is required to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" (using","type":"text"},{"text":" ","type":"text"},{"code":"ChannelHandlerContext.removeHandler","type":"codeVoice"},{"text":") as soon as possible.","type":"text"}],"topicSections":[{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler"},"kind":"symbol","variants":[{"paths":["\/documentation\/niocore\/removablechannelhandler"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["Linux"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","preciseIdentifier":"s:7NIOCore14ChannelHandlerP","text":"ChannelHandler"}],"languages":["swift"]}]},{"kind":"content","content":[{"anchor":"overview","text":"Overview","level":2,"type":"heading"},{"name":"Note","content":[{"inlineContent":[{"type":"text","text":"When a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" gets torn down, every "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" in the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"’s "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" will be"},{"type":"text","text":" "},{"type":"text","text":"removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". Those removals however happen synchronously and are not going through"},{"type":"text","text":" "},{"type":"text","text":"the methods of this protocol."}],"type":"paragraph"}],"type":"aside","style":"note"}]}],"relationshipsSections":[{"title":"Inherits From","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"],"type":"inheritsFrom"},{"title":"Conforming Types","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPRequestHeadersValidator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPResponseHeadersValidator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler"],"type":"conformingTypes"}],"metadata":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"RemovableChannelHandler"}],"title":"RemovableChannelHandler","externalID":"s:7NIOCore23RemovableChannelHandlerP","navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}],"modules":[{"name":"NIOCore"}],"roleHeading":"Protocol","role":"symbol","symbolKind":"protocol"},"references":{"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerUpgradeHandler":{"abstract":[{"text":"A server-side channel handler that receives HTTP requests and optionally performs a HTTP-upgrade.","type":"text"},{"text":" ","type":"text"},{"text":"Removes itself from the channel pipeline after the first inbound request on the connection, regardless of","type":"text"},{"text":" ","type":"text"},{"text":"whether the upgrade succeeded or not.","type":"text"}],"url":"\/documentation\/niohttp1\/httpserverupgradehandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","title":"HTTPServerUpgradeHandler","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPRequestEncoder":{"navigatorTitle":[{"kind":"identifier","text":"HTTPRequestEncoder"}],"title":"HTTPRequestEncoder","role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/niohttp1\/httprequestencoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPRequestEncoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelOutboundHandler"},{"text":" that can serialize HTTP requests.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestDecompressor":{"kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestDecompressor"}],"abstract":[{"type":"text","text":"Channel hander to decompress incoming HTTP data."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestDecompressor"}],"url":"\/documentation\/niohttpcompression\/niohttprequestdecompressor","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","title":"NIOHTTPRequestDecompressor"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/BackPressureHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","url":"\/documentation\/niocore\/backpressurehandler","type":"topic","kind":"symbol","role":"symbol","title":"BackPressureHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BackPressureHandler","kind":"identifier"}],"abstract":[{"text":"ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough.","type":"text"},{"text":" ","type":"text"},{"text":"It will start reading again once pending data was written.","type":"text"}],"navigatorTitle":[{"text":"BackPressureHandler","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPServerRequestAggregator":{"abstract":[{"text":"A ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that handles HTTP chunked ","type":"text"},{"code":"HTTPServerRequestPart","type":"codeVoice"},{"text":" ","type":"text"},{"text":"messages by aggregating individual message chunks into a single","type":"text"},{"text":" ","type":"text"},{"code":"NIOHTTPServerRequestFull","type":"codeVoice"},{"text":".","type":"text"}],"url":"\/documentation\/niohttp1\/niohttpserverrequestaggregator","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","title":"NIOHTTPServerRequestAggregator","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPServerRequestAggregator"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPServerRequestAggregator"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSServerHandshakeHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler","url":"\/documentation\/niosocks\/socksserverhandshakehandler","type":"topic","kind":"symbol","role":"symbol","title":"SOCKSServerHandshakeHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SOCKSServerHandshakeHandler","kind":"identifier"}],"abstract":[{"text":"Add this handshake handler to the front of your channel, closest to the network.","type":"text"},{"text":" ","type":"text"},{"text":"The handler will receive bytes from the network and run them through a state machine","type":"text"},{"text":" ","type":"text"},{"text":"and parser to enforce SOCKSv5 protocol correctness. Inbound bytes will by parsed into","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ClientMessage"},{"text":" for downstream consumption. Send ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ServerMessage"},{"text":" to this","type":"text"},{"text":" ","type":"text"},{"text":"handler.","type":"text"}],"navigatorTitle":[{"text":"SOCKSServerHandshakeHandler","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IdleStateHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","url":"\/documentation\/niocore\/idlestatehandler","type":"topic","kind":"symbol","role":"symbol","title":"IdleStateHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"IdleStateHandler","kind":"identifier"}],"abstract":[{"text":"Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while.","type":"text"}],"navigatorTitle":[{"text":"IdleStateHandler","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelHandler":{"title":"ChannelHandler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","kind":"symbol","abstract":[{"type":"text","text":"You should "},{"inlineContent":[{"text":"never","type":"text"}],"type":"emphasis"},{"type":"text","text":" implement this protocol directly. Please implement one of its sub-protocols."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"ChannelHandler"}],"url":"\/documentation\/niocore\/channelhandler","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/HTTPResponseCompressor":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","abstract":[{"type":"text","text":"A "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","isActive":true},{"type":"text","text":" is a duplex channel handler that handles automatic streaming compression of"},{"type":"text","text":" "},{"type":"text","text":"HTTP responses. It respects the client’s Accept-Encoding preferences, including q-values if present,"},{"type":"text","text":" "},{"type":"text","text":"and ensures that clients are served the compression algorithm that works best for them."}],"url":"\/documentation\/niohttpcompression\/httpresponsecompressor","type":"topic","role":"symbol","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"HTTPResponseCompressor"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPResponseCompressor"}],"title":"HTTPResponseCompressor"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageHandler":{"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Decoder"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"."}]},"abstract":[{"text":"A handler which turns a given ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" into a ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that can then be added to a","type":"text"},{"text":" ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":".","type":"text"}],"url":"\/documentation\/niocore\/bytetomessagehandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","title":"ByteToMessageHandler","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ByteToMessageHandler"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageHandler"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPRequestHeadersValidator":{"fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestHeadersValidator"}],"title":"NIOHTTPRequestHeadersValidator","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPRequestHeadersValidator","role":"symbol","url":"\/documentation\/niohttp1\/niohttprequestheadersvalidator","type":"topic","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestHeadersValidator"}],"abstract":[{"type":"text","text":"A ChannelHandler to validate that outbound request headers are spec-compliant."}]},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/ApplicationProtocolNegotiationHandler":{"abstract":[{"text":"A helper ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that makes it easy to swap channel pipelines","type":"text"},{"text":" ","type":"text"},{"text":"based on the result of an ALPN negotiation.","type":"text"}],"url":"\/documentation\/niotls\/applicationprotocolnegotiationhandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","title":"ApplicationProtocolNegotiationHandler","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ApplicationProtocolNegotiationHandler"}],"fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"ApplicationProtocolNegotiationHandler"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerPipelineHandler":{"kind":"symbol","role":"symbol","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler","abstract":[{"text":"A ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that handles HTTP pipelining by buffering inbound data until a","type":"text"},{"text":" ","type":"text"},{"text":"response has been sent.","type":"text"}],"navigatorTitle":[{"text":"HTTPServerPipelineHandler","kind":"identifier"}],"url":"\/documentation\/niohttp1\/httpserverpipelinehandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPServerPipelineHandler","kind":"identifier"}],"title":"HTTPServerPipelineHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPResponseEncoder":{"title":"HTTPResponseEncoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPResponseEncoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","kind":"symbol","abstract":[{"type":"text","text":"A "},{"code":"ChannelOutboundHandler","type":"codeVoice"},{"type":"text","text":" that can serialize HTTP responses."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"HTTPResponseEncoder"}],"url":"\/documentation\/niohttp1\/httpresponseencoder","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AcceptBackoffHandler":{"navigatorTitle":[{"text":"AcceptBackoffHandler","kind":"identifier"}],"url":"\/documentation\/niocore\/acceptbackoffhandler","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that implements a backoff for a "},{"type":"codeVoice","code":"ServerChannel"},{"type":"text","text":" when accept produces an "},{"type":"codeVoice","code":"IOError"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These errors are often recoverable by reducing the rate at which we call accept."}],"title":"AcceptBackoffHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AcceptBackoffHandler","kind":"identifier"}],"type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLHandler","kind":"identifier"}],"navigatorTitle":[{"text":"NIOSSLHandler","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niossl\/niosslhandler","abstract":[{"text":"The base class for all NIOSSL handlers.","type":"text"}],"title":"NIOSSLHandler","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOWritePCAPHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOWritePCAPHandler"}],"title":"NIOWritePCAPHandler","role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/nioextras\/niowritepcaphandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOWritePCAPHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that can write a ","type":"text"},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","isActive":true,"type":"reference"},{"text":" containing the send\/received","type":"text"},{"text":" ","type":"text"},{"text":"data as synthesized TCP packet captures.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientResponseAggregator":{"navigatorTitle":[{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"abstract":[{"text":"A ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that handles HTTP chunked ","type":"text"},{"code":"HTTPClientResponsePart","type":"codeVoice"},{"text":" ","type":"text"},{"text":"messages by aggregating individual message chunks into a single","type":"text"},{"text":" ","type":"text"},{"code":"NIOHTTPClientResponseFull","type":"codeVoice"},{"text":".","type":"text"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niohttp1\/niohttpclientresponseaggregator","role":"symbol","title":"NIOHTTPClientResponseAggregator","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/ServerMessage":{"title":"ServerMessage","navigatorTitle":[{"kind":"identifier","text":"ServerMessage"}],"fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"ServerMessage"}],"role":"symbol","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ServerMessage","url":"\/documentation\/niosocks\/servermessage","type":"topic","abstract":[{"type":"text","text":"Sent by the server and received by the client."}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestCompressor":{"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor"},{"text":" is an outbound channel handler that handles automatic streaming compression of","type":"text"},{"text":" ","type":"text"},{"text":"HTTP requests.","type":"text"}],"type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPRequestCompressor","kind":"identifier"}],"url":"\/documentation\/niohttpcompression\/niohttprequestcompressor","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","navigatorTitle":[{"text":"NIOHTTPRequestCompressor","kind":"identifier"}],"role":"symbol","kind":"symbol","title":"NIOHTTPRequestCompressor"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientUpgradeHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","url":"\/documentation\/niohttp1\/niohttpclientupgradehandler","type":"topic","kind":"symbol","role":"symbol","title":"NIOHTTPClientUpgradeHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPClientUpgradeHandler","kind":"identifier"}],"abstract":[{"text":"A client-side channel handler that sends a HTTP upgrade handshake request to perform a HTTP-upgrade.","type":"text"},{"text":" ","type":"text"},{"text":"When the first HTTP request is sent, this handler will add all appropriate headers to perform an upgrade to","type":"text"},{"text":" ","type":"text"},{"text":"the a protocol. It may add headers for a set of protocols in preference order.","type":"text"},{"text":" ","type":"text"},{"text":"If the upgrade fails (i.e. response is not 101 Switching Protocols), this handler simply","type":"text"},{"text":" ","type":"text"},{"text":"removes itself from the pipeline. If the upgrade is successful, it upgrades the pipeline to the new protocol.","type":"text"}],"navigatorTitle":[{"text":"NIOHTTPClientUpgradeHandler","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPResponseHeadersValidator":{"abstract":[{"text":"A ChannelHandler to validate that outbound response headers are spec-compliant.","type":"text"}],"title":"NIOHTTPResponseHeadersValidator","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPResponseHeadersValidator","kind":"identifier"}],"url":"\/documentation\/niohttp1\/niohttpresponseheadersvalidator","type":"topic","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"NIOHTTPResponseHeadersValidator","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPResponseHeadersValidator"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSClientHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","url":"\/documentation\/niosocks\/socksclienthandler","type":"topic","kind":"symbol","role":"symbol","title":"SOCKSClientHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SOCKSClientHandler","kind":"identifier"}],"abstract":[{"type":"text","text":"Connects to a SOCKS server to establish a proxied connection"},{"type":"text","text":" "},{"type":"text","text":"to a host. This handler should be inserted at the beginning of a"},{"type":"text","text":" "},{"type":"text","text":"channel’s pipeline. Note that SOCKS only supports fully-qualified"},{"type":"text","text":" "},{"type":"text","text":"domain names and IPv4 or IPv6 sockets, and not UNIX sockets."}],"navigatorTitle":[{"text":"SOCKSClientHandler","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLServerHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLServerHandler","kind":"identifier"}],"navigatorTitle":[{"text":"NIOSSLServerHandler","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niossl\/niosslserverhandler","abstract":[{"text":"A channel handler that wraps a channel in TLS using NIOSSL. This","type":"text"},{"text":" ","type":"text"},{"text":"handler can be used in channels that are acting as the server in","type":"text"},{"text":" ","type":"text"},{"text":"the TLS dialog. For client connections, use the ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler"},{"text":".","type":"text"}],"title":"NIOSSLServerHandler","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","title":"RemovableChannelHandler","kind":"symbol","type":"topic","url":"\/documentation\/niocore\/removablechannelhandler","role":"symbol","abstract":[{"type":"text","text":"A "},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is a ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that can be dynamically removed from a ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" whilst","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" is operating normally.","type":"text"},{"text":" ","type":"text"},{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is required to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" (using","type":"text"},{"text":" ","type":"text"},{"code":"ChannelHandlerContext.removeHandler","type":"codeVoice"},{"text":") as soon as possible.","type":"text"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"}],"navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler/removeHandler(context:removalToken:)-2jaoc":{"defaultImplementations":1,"abstract":[{"text":"Ask the receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" as soon as possible.","type":"text"},{"text":" ","type":"text"},{"text":"The receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" may elect to remove itself sometime after this method call, rather than","type":"text"},{"text":" ","type":"text"},{"text":"immediately, but if it does so it must take the necessary precautions to handle events arriving between the","type":"text"},{"text":" ","type":"text"},{"text":"invocation of this method and the call to ","type":"text"},{"code":"ChannelHandlerContext.removeHandler","type":"codeVoice"},{"text":" that triggers the actual","type":"text"},{"text":" ","type":"text"},{"text":"removal.","type":"text"}],"url":"\/documentation\/niocore\/removablechannelhandler\/removehandler(context:removaltoken:)-2jaoc","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc","title":"removeHandler(context:removalToken:)","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"removeHandler"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":", "},{"kind":"externalParam","text":"removalToken"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":"."},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC12RemovalTokenV","kind":"typeIdentifier","text":"RemovalToken"},{"kind":"text","text":")"}],"required":true,"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","role":"collection","kind":"symbol","type":"topic","abstract":[],"title":"NIOCore","url":"\/documentation\/niocore"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLClientHandler":{"type":"topic","url":"\/documentation\/niossl\/niosslclienthandler","kind":"symbol","title":"NIOSSLClientHandler","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLClientHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","navigatorTitle":[{"text":"NIOSSLClientHandler","kind":"identifier"}],"abstract":[{"text":"A channel handler that wraps a channel in TLS using NIOSSL.","type":"text"},{"text":" ","type":"text"},{"text":"This handler can be used in channels that are acting as the client","type":"text"},{"text":" ","type":"text"},{"text":"in the TLS dialog. For server connections, use the ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler"},{"text":".","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerProtocolErrorHandler":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","url":"\/documentation\/niohttp1\/httpserverprotocolerrorhandler","type":"topic","kind":"symbol","role":"symbol","title":"HTTPServerProtocolErrorHandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"abstract":[{"text":"A simple channel handler that catches errors emitted by parsing HTTP requests","type":"text"},{"text":" ","type":"text"},{"text":"and sends 400 Bad Request responses.","type":"text"}],"navigatorTitle":[{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}]},"https://en.wikipedia.org/wiki/Pcap":{"type":"link","title":".pcap file","url":"https:\/\/en.wikipedia.org\/wiki\/Pcap","titleInlineContent":[{"code":".pcap","type":"codeVoice"},{"text":" file","type":"text"}],"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPResponseDecompressor":{"title":"NIOHTTPResponseDecompressor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPResponseDecompressor"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","kind":"symbol","abstract":[{"type":"text","text":"Duplex channel handler which will accept deflate and gzip encoded responses and decompress them."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPResponseDecompressor"}],"url":"\/documentation\/niohttpcompression\/niohttpresponsedecompressor","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/ClientMessage":{"fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"ClientMessage"}],"abstract":[{"type":"text","text":"Sent by the client and received by the server."}],"navigatorTitle":[{"kind":"identifier","text":"ClientMessage"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ClientMessage","title":"ClientMessage","role":"symbol","type":"topic","url":"\/documentation\/niosocks\/clientmessage","kind":"symbol"}}}