{"abstract":[{"type":"text","text":"A configuration option that can be set on a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" to configure different behaviour."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption"},"sections":[],"kind":"symbol","metadata":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelOption","kind":"identifier"}],"symbolKind":"protocol","externalID":"s:7NIOCore13ChannelOptionP","role":"symbol","roleHeading":"Protocol","title":"ChannelOption","navigatorTitle":[{"text":"ChannelOption","kind":"identifier"}],"modules":[{"name":"NIOCore"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"schemaVersion":{"minor":3,"patch":0,"major":0},"relationshipsSections":[{"kind":"relationships","type":"inheritsFrom","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","doc:\/\/co.pointfree.VaporRouting\/SQ"],"title":"Inherits From"},{"kind":"relationships","type":"conformingTypes","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AutoReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/BacklogOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ConnectTimeoutOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/MaxMessagesPerReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ReceivePacketInfo","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/RecvAllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/SocketOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteSpinOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption"],"title":"Conforming Types"}],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"},{"kind":"text","text":" : "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","kind":"typeIdentifier","text":"NIOPreconcurrencySendable","preciseIdentifier":"s:7NIOCore25NIOPreconcurrencySendableP"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Equatable","preciseIdentifier":"s:SQ"}],"languages":["swift"],"platforms":["Linux"]}]}],"topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption\/Value"],"title":"Associated Types"}],"variants":[{"paths":["\/documentation\/niocore\/channeloption"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/BacklogOption":{"navigatorTitle":[{"kind":"identifier","text":"BacklogOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/backlogoption","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/BacklogOption","abstract":[{"code":"BacklogOption","type":"codeVoice"},{"type":"text","text":" allows users to configure the "},{"code":"backlog","type":"codeVoice"},{"type":"text","text":" value as specified in "},{"code":"man 2 listen","type":"codeVoice"},{"type":"text","text":". This is only useful for "},{"code":"ServerSocketChannel","type":"codeVoice"},{"type":"text","text":"s."}],"title":"ChannelOptions.Types.BacklogOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"BacklogOption"}],"type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ExplicitCongestionNotificationsOption":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","title":"ChannelOptions.Types.ExplicitCongestionNotificationsOption","abstract":[{"type":"text","text":"When set to true IP level ECN information will be reported through "},{"code":"AddressedEnvelope.Metadata","type":"codeVoice"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/explicitcongestionnotificationsoption","navigatorTitle":[{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/WriteSpinOption":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteSpinOption","kind":"identifier"}],"role":"symbol","abstract":[{"type":"codeVoice","code":"WriteSpinOption"},{"type":"text","text":" allows users to configure the number of repetitions of a only partially successful write call before considering the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."},{"type":"text","text":" "},{"type":"text","text":"Setting this option to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" means that we only issue one write call and if that call does not write all the bytes,"},{"type":"text","text":" "},{"type":"text","text":"we consider the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."}],"type":"topic","kind":"symbol","title":"ChannelOptions.Types.WriteSpinOption","navigatorTitle":[{"text":"WriteSpinOption","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteSpinOption","url":"\/documentation\/niocore\/channeloptions\/types\/writespinoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/RecvAllocatorOption":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/RecvAllocatorOption","title":"ChannelOptions.Types.RecvAllocatorOption","navigatorTitle":[{"kind":"identifier","text":"RecvAllocatorOption"}],"type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/recvallocatoroption","role":"symbol","abstract":[{"code":"RecvAllocatorOption","type":"codeVoice"},{"type":"text","text":" allows users to specify the "},{"code":"RecvByteBufferAllocator","type":"codeVoice"},{"type":"text","text":" to use."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"RecvAllocatorOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOption/Value":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption\/Value","title":"Value","abstract":[{"type":"text","text":"The type of the "},{"code":"ChannelOption","type":"codeVoice"},{"text":"â€™s value.","type":"text"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"Value"}],"type":"topic","url":"\/documentation\/niocore\/channeloption\/value","required":true,"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AutoReadOption":{"role":"symbol","navigatorTitle":[{"text":"AutoReadOption","kind":"identifier"}],"abstract":[{"type":"codeVoice","code":"AutoReadOption"},{"type":"text","text":" allows users to configure if a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" should automatically call "},{"code":"Channel.read","type":"codeVoice"},{"type":"text","text":" again once all data was read from the transport or"},{"type":"text","text":" "},{"type":"text","text":"if the user is responsible to call "},{"code":"Channel.read","type":"codeVoice"},{"text":" manually.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AutoReadOption","kind":"identifier"}],"type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/autoreadoption","title":"ChannelOptions.Types.AutoReadOption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AutoReadOption","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AllowRemoteHalfClosureOption":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","kind":"symbol","role":"symbol","abstract":[{"code":"AllowRemoteHalfClosureOption","type":"codeVoice"},{"type":"text","text":" allows users to configure whether the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will close itself when its remote"},{"type":"text","text":" "},{"type":"text","text":"peer shuts down its send stream, or whether it will remain open. If set to "},{"type":"codeVoice","code":"false"},{"type":"text","text":" (the default), the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" "},{"type":"text","text":"will be closed automatically if the remote peer shuts down its send stream. If set to true, the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will"},{"type":"text","text":" "},{"type":"text","text":"not be closed: instead, a "},{"type":"codeVoice","code":"ChannelEvent.inboundClosed"},{"type":"text","text":" user event will be sent on the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and no more data will be received."}],"title":"ChannelOptions.Types.AllowRemoteHalfClosureOption","url":"\/documentation\/niocore\/channeloptions\/types\/allowremotehalfclosureoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ReceivePacketInfo":{"title":"ChannelOptions.Types.ReceivePacketInfo","navigatorTitle":[{"text":"ReceivePacketInfo","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ReceivePacketInfo","abstract":[{"type":"text","text":"When set to true IP level Packet Info information will be reported through "},{"code":"AddressedEnvelope.Metadata","type":"codeVoice"},{"type":"text","text":" for UDP packets."}],"role":"symbol","url":"\/documentation\/niocore\/channeloptions\/types\/receivepacketinfo","type":"topic","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ReceivePacketInfo","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","role":"collection","kind":"symbol","type":"topic","abstract":[],"title":"NIOCore","url":"\/documentation\/niocore"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP2/HTTP2StreamChannelOptions/Types/StreamIDOption":{"role":"symbol","kind":"symbol","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption"},{"type":"text","text":" allows users to query the stream ID for a given "},{"type":"codeVoice","code":"HTTP2StreamChannel"},{"type":"text","text":"."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption","url":"\/documentation\/niohttp2\/http2streamchanneloptions\/types\/streamidoption","navigatorTitle":[{"kind":"identifier","text":"StreamIDOption"}],"title":"HTTP2StreamChannelOptions.Types.StreamIDOption","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"StreamIDOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AllocatorOption":{"role":"symbol","navigatorTitle":[{"text":"AllocatorOption","kind":"identifier"}],"abstract":[{"type":"codeVoice","code":"AllocatorOption"},{"text":" allows to specify the ","type":"text"},{"type":"codeVoice","code":"ByteBufferAllocator"},{"text":" to use.","type":"text"}],"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AllocatorOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/allocatoroption","kind":"symbol","title":"ChannelOptions.Types.AllocatorOption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllocatorOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOption":{"title":"ChannelOption","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption","kind":"symbol","abstract":[{"type":"text","text":"A configuration option that can be set on a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" to configure different behaviour."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"ChannelOption"}],"url":"\/documentation\/niocore\/channeloption","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPreconcurrencySendable":{"title":"NIOPreconcurrencySendable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","kind":"symbol","abstract":[],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"url":"\/documentation\/niocore\/niopreconcurrencysendable","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/MaxMessagesPerReadOption":{"title":"ChannelOptions.Types.MaxMessagesPerReadOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MaxMessagesPerReadOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/MaxMessagesPerReadOption","kind":"symbol","abstract":[{"code":"MaxMessagesPerReadOption","type":"codeVoice"},{"type":"text","text":" allows users to configure the maximum number of read calls to the underlying transport are performed before wait again until"},{"type":"text","text":" "},{"type":"text","text":"there is more to read and be notified."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"MaxMessagesPerReadOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/maxmessagesperreadoption","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/DatagramVectorReadMessageCountOption":{"abstract":[{"code":"DatagramVectorReadMessageCountOption","type":"codeVoice"},{"text":" allows users to configure the number of messages to attempt to read in a single syscall on a","type":"text"},{"text":" ","type":"text"},{"text":"datagram ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":".","type":"text"}],"title":"ChannelOptions.Types.DatagramVectorReadMessageCountOption","type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/datagramvectorreadmessagecountoption","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ConnectTimeoutOption":{"type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ConnectTimeoutOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/connecttimeoutoption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ConnectTimeoutOption","abstract":[{"type":"codeVoice","code":"ConnectTimeoutOption"},{"type":"text","text":" allows users to configure the "},{"type":"codeVoice","code":"TimeAmount"},{"type":"text","text":" after which a connect will fail if it was not established in the meantime. May be"},{"type":"text","text":" "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", in which case the connection attempt will never time out."}],"navigatorTitle":[{"kind":"identifier","text":"ConnectTimeoutOption"}],"kind":"symbol","title":"ChannelOptions.Types.ConnectTimeoutOption","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/WriteBufferWaterMarkOption":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","kind":"symbol","title":"ChannelOptions.Types.WriteBufferWaterMarkOption","role":"symbol","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteBufferWaterMarkOption","kind":"identifier"}],"navigatorTitle":[{"text":"WriteBufferWaterMarkOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/writebufferwatermarkoption","abstract":[{"type":"codeVoice","code":"WriteBufferWaterMarkOption"},{"text":" allows users to configure when a ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":" should be marked as writable or not. Once the amount of bytes queued in a","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"s outbound buffer is larger than "},{"code":"WriteBufferWaterMark.high","type":"codeVoice"},{"type":"text","text":" the channel will be marked as non-writable and so"},{"type":"text","text":" "},{"type":"codeVoice","code":"Channel.isWritable"},{"type":"text","text":" will return "},{"type":"codeVoice","code":"false"},{"type":"text","text":". Once we were able to write some data out of the outbound buffer and the amount of bytes queued"},{"type":"text","text":" "},{"type":"text","text":"falls below "},{"type":"codeVoice","code":"WriteBufferWaterMark.low"},{"type":"text","text":" the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will become writable again. Once this happens "},{"type":"codeVoice","code":"Channel.writable"},{"type":"text","text":" will return"},{"type":"text","text":" "},{"type":"codeVoice","code":"true"},{"type":"text","text":" again. These writability changes are also propagated through the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" and so can be intercepted via "},{"type":"codeVoice","code":"ChannelInboundHandler.channelWritabilityChanged"},{"type":"text","text":"."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/SocketOption":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SocketOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/socketoption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/SocketOption","abstract":[{"type":"codeVoice","code":"SocketOption"},{"text":" allows users to specify configuration settings that are directly applied to the underlying socket file descriptor.","type":"text"}],"type":"topic","title":"ChannelOptions.Types.SocketOption","role":"symbol","navigatorTitle":[{"text":"SocketOption","kind":"identifier"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/SQ":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/SQ","title":"Swift.Equatable","type":"unresolvable"}}}