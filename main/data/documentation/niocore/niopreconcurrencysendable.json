{"schemaVersion":{"patch":0,"minor":3,"major":0},"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOPreconcurrencySendable","kind":"identifier"}],"languages":["swift"],"platforms":["Linux"]}]}],"metadata":{"title":"NIOPreconcurrencySendable","symbolKind":"protocol","roleHeading":"Protocol","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"modules":[{"name":"NIOCore"}],"navigatorTitle":[{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"externalID":"s:7NIOCore25NIOPreconcurrencySendableP"},"relationshipsSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Channel","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoop","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopGroup","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MulticastChannel","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RecvByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionProvider"],"title":"Inherited By","kind":"relationships","type":"inheritedBy"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AdaptiveRecvByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AutoReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/BacklogOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ConnectTimeoutOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/MaxMessagesPerReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ReceivePacketInfo","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/RecvAllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/SocketOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteSpinOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOEmbedded\/EmbeddedChannel","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOEmbedded\/EmbeddedEventLoop","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FixedSizeRecvByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOPosix\/MultiThreadedEventLoopGroup"],"title":"Conforming Types","kind":"relationships","type":"conformingTypes"}],"kind":"symbol","sections":[],"variants":[{"paths":["\/documentation\/niocore\/niopreconcurrencysendable"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable"},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"references":{"doc://co.pointfree.VaporRouting/documentation/NIOPosix/MultiThreadedEventLoopGroup":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"MultiThreadedEventLoopGroup"}],"kind":"symbol","role":"symbol","type":"topic","title":"MultiThreadedEventLoopGroup","url":"\/documentation\/nioposix\/multithreadedeventloopgroup","abstract":[{"type":"text","text":"An "},{"type":"codeVoice","code":"EventLoopGroup"},{"type":"text","text":" which will create multiple "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":"s, each tied to its own "},{"type":"codeVoice","code":"NIOThread"},{"type":"text","text":"."}],"navigatorTitle":[{"kind":"identifier","text":"MultiThreadedEventLoopGroup"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOPosix\/MultiThreadedEventLoopGroup"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/MaxMessagesPerReadOption":{"title":"ChannelOptions.Types.MaxMessagesPerReadOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"MaxMessagesPerReadOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/MaxMessagesPerReadOption","kind":"symbol","abstract":[{"code":"MaxMessagesPerReadOption","type":"codeVoice"},{"type":"text","text":" allows users to configure the maximum number of read calls to the underlying transport are performed before wait again until"},{"type":"text","text":" "},{"type":"text","text":"there is more to read and be notified."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"MaxMessagesPerReadOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/maxmessagesperreadoption","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AdaptiveRecvByteBufferAllocator":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AdaptiveRecvByteBufferAllocator"}],"url":"\/documentation\/niocore\/adaptiverecvbytebufferallocator","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AdaptiveRecvByteBufferAllocator","title":"AdaptiveRecvByteBufferAllocator","role":"symbol","kind":"symbol","abstract":[{"code":"RecvByteBufferAllocator","type":"codeVoice"},{"text":" which will gracefully increment or decrement the buffer size on the feedback that was recorded.","type":"text"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"AdaptiveRecvByteBufferAllocator"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP2/HTTP2StreamChannelOptions/Types/StreamIDOption":{"role":"symbol","kind":"symbol","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption"},{"type":"text","text":" allows users to query the stream ID for a given "},{"type":"codeVoice","code":"HTTP2StreamChannel"},{"type":"text","text":"."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP2\/HTTP2StreamChannelOptions\/Types\/StreamIDOption","url":"\/documentation\/niohttp2\/http2streamchanneloptions\/types\/streamidoption","navigatorTitle":[{"kind":"identifier","text":"StreamIDOption"}],"title":"HTTP2StreamChannelOptions.Types.StreamIDOption","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"StreamIDOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/MulticastChannel":{"url":"\/documentation\/niocore\/multicastchannel","type":"topic","title":"MulticastChannel","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MulticastChannel","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"MulticastChannel"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"MulticastChannel"}],"abstract":[{"text":"A ","type":"text"},{"code":"MulticastChannel","type":"codeVoice"},{"text":" is a ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" that supports IP multicast operations: that is, a channel that can join multicast","type":"text"},{"text":" ","type":"text"},{"text":"groups.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/WriteBufferWaterMarkOption":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteBufferWaterMarkOption","kind":"symbol","title":"ChannelOptions.Types.WriteBufferWaterMarkOption","role":"symbol","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteBufferWaterMarkOption","kind":"identifier"}],"navigatorTitle":[{"text":"WriteBufferWaterMarkOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/writebufferwatermarkoption","abstract":[{"type":"codeVoice","code":"WriteBufferWaterMarkOption"},{"text":" allows users to configure when a ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":" should be marked as writable or not. Once the amount of bytes queued in a","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"s outbound buffer is larger than "},{"code":"WriteBufferWaterMark.high","type":"codeVoice"},{"type":"text","text":" the channel will be marked as non-writable and so"},{"type":"text","text":" "},{"type":"codeVoice","code":"Channel.isWritable"},{"type":"text","text":" will return "},{"type":"codeVoice","code":"false"},{"type":"text","text":". Once we were able to write some data out of the outbound buffer and the amount of bytes queued"},{"type":"text","text":" "},{"type":"text","text":"falls below "},{"type":"codeVoice","code":"WriteBufferWaterMark.low"},{"type":"text","text":" the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will become writable again. Once this happens "},{"type":"codeVoice","code":"Channel.writable"},{"type":"text","text":" will return"},{"type":"text","text":" "},{"type":"codeVoice","code":"true"},{"type":"text","text":" again. These writability changes are also propagated through the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" and so can be intercepted via "},{"type":"codeVoice","code":"ChannelInboundHandler.channelWritabilityChanged"},{"type":"text","text":"."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketOptionProvider":{"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionProvider","navigatorTitle":[{"kind":"identifier","text":"SocketOptionProvider"}],"title":"SocketOptionProvider","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketOptionProvider"}],"type":"topic","url":"\/documentation\/niocore\/socketoptionprovider","abstract":[{"type":"text","text":"This protocol defines an object, most commonly a "},{"type":"codeVoice","code":"Channel"},{"text":", that supports","type":"text"},{"text":" ","type":"text"},{"text":"setting and getting socket options (via ","type":"text"},{"code":"setsockopt","type":"codeVoice"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"getsockopt"},{"type":"text","text":" or similar)."},{"type":"text","text":" "},{"type":"text","text":"It provides a strongly typed API that makes working with larger, less-common"},{"type":"text","text":" "},{"type":"text","text":"socket options easier than the "},{"type":"codeVoice","code":"ChannelOption"},{"type":"text","text":" API allows."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ExplicitCongestionNotificationsOption":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ExplicitCongestionNotificationsOption","title":"ChannelOptions.Types.ExplicitCongestionNotificationsOption","abstract":[{"type":"text","text":"When set to true IP level ECN information will be reported through "},{"code":"AddressedEnvelope.Metadata","type":"codeVoice"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/explicitcongestionnotificationsoption","navigatorTitle":[{"kind":"identifier","text":"ExplicitCongestionNotificationsOption"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOption":{"title":"ChannelOption","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption","kind":"symbol","abstract":[{"type":"text","text":"A configuration option that can be set on a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" to configure different behaviour."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"ChannelOption"}],"url":"\/documentation\/niocore\/channeloption","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ConnectTimeoutOption":{"type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ConnectTimeoutOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/connecttimeoutoption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ConnectTimeoutOption","abstract":[{"type":"codeVoice","code":"ConnectTimeoutOption"},{"type":"text","text":" allows users to configure the "},{"type":"codeVoice","code":"TimeAmount"},{"type":"text","text":" after which a connect will fail if it was not established in the meantime. May be"},{"type":"text","text":" "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", in which case the connection attempt will never time out."}],"navigatorTitle":[{"kind":"identifier","text":"ConnectTimeoutOption"}],"kind":"symbol","title":"ChannelOptions.Types.ConnectTimeoutOption","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AllowRemoteHalfClosureOption":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllowRemoteHalfClosureOption","kind":"symbol","role":"symbol","abstract":[{"code":"AllowRemoteHalfClosureOption","type":"codeVoice"},{"type":"text","text":" allows users to configure whether the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will close itself when its remote"},{"type":"text","text":" "},{"type":"text","text":"peer shuts down its send stream, or whether it will remain open. If set to "},{"type":"codeVoice","code":"false"},{"type":"text","text":" (the default), the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" "},{"type":"text","text":"will be closed automatically if the remote peer shuts down its send stream. If set to true, the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" will"},{"type":"text","text":" "},{"type":"text","text":"not be closed: instead, a "},{"type":"codeVoice","code":"ChannelEvent.inboundClosed"},{"type":"text","text":" user event will be sent on the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and no more data will be received."}],"title":"ChannelOptions.Types.AllowRemoteHalfClosureOption","url":"\/documentation\/niocore\/channeloptions\/types\/allowremotehalfclosureoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AutoReadOption":{"role":"symbol","navigatorTitle":[{"text":"AutoReadOption","kind":"identifier"}],"abstract":[{"type":"codeVoice","code":"AutoReadOption"},{"type":"text","text":" allows users to configure if a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" should automatically call "},{"code":"Channel.read","type":"codeVoice"},{"type":"text","text":" again once all data was read from the transport or"},{"type":"text","text":" "},{"type":"text","text":"if the user is responsible to call "},{"code":"Channel.read","type":"codeVoice"},{"text":" manually.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AutoReadOption","kind":"identifier"}],"type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/autoreadoption","title":"ChannelOptions.Types.AutoReadOption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AutoReadOption","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOEmbedded/EmbeddedChannel":{"kind":"symbol","role":"symbol","title":"EmbeddedChannel","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOEmbedded\/EmbeddedChannel","abstract":[{"type":"codeVoice","code":"EmbeddedChannel"},{"type":"text","text":" is a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" implementation that does neither any"},{"type":"text","text":" "},{"type":"text","text":"actual IO nor has a proper eventing mechanism. The prime use-case for"},{"type":"text","text":" "},{"code":"EmbeddedChannel","type":"codeVoice"},{"text":" is in unit tests when you want to feed the inbound events","type":"text"},{"text":" ","type":"text"},{"text":"and check the outbound events manually.","type":"text"}],"url":"\/documentation\/nioembedded\/embeddedchannel","type":"topic","navigatorTitle":[{"text":"EmbeddedChannel","kind":"identifier"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EmbeddedChannel","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoopGroup":{"type":"topic","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EventLoopGroup"}],"url":"\/documentation\/niocore\/eventloopgroup","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"EventLoopGroup"}],"title":"EventLoopGroup","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopGroup","abstract":[{"type":"text","text":"Provides an endless stream of "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":"s to use."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/WriteSpinOption":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteSpinOption","kind":"identifier"}],"role":"symbol","abstract":[{"type":"codeVoice","code":"WriteSpinOption"},{"type":"text","text":" allows users to configure the number of repetitions of a only partially successful write call before considering the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."},{"type":"text","text":" "},{"type":"text","text":"Setting this option to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" means that we only issue one write call and if that call does not write all the bytes,"},{"type":"text","text":" "},{"type":"text","text":"we consider the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" not writable."}],"type":"topic","kind":"symbol","title":"ChannelOptions.Types.WriteSpinOption","navigatorTitle":[{"text":"WriteSpinOption","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/WriteSpinOption","url":"\/documentation\/niocore\/channeloptions\/types\/writespinoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RecvByteBufferAllocator":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RecvByteBufferAllocator"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RecvByteBufferAllocator","type":"topic","url":"\/documentation\/niocore\/recvbytebufferallocator","kind":"symbol","title":"RecvByteBufferAllocator","navigatorTitle":[{"kind":"identifier","text":"RecvByteBufferAllocator"}],"abstract":[{"text":"Allocates ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":"s to be used to read bytes from a ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" and records the number of the actual bytes that were used.","type":"text"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/ReceivePacketInfo":{"title":"ChannelOptions.Types.ReceivePacketInfo","navigatorTitle":[{"text":"ReceivePacketInfo","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/ReceivePacketInfo","abstract":[{"type":"text","text":"When set to true IP level Packet Info information will be reported through "},{"code":"AddressedEnvelope.Metadata","type":"codeVoice"},{"type":"text","text":" for UDP packets."}],"role":"symbol","url":"\/documentation\/niocore\/channeloptions\/types\/receivepacketinfo","type":"topic","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ReceivePacketInfo","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/FixedSizeRecvByteBufferAllocator":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FixedSizeRecvByteBufferAllocator","abstract":[{"code":"RecvByteBufferAllocator","type":"codeVoice"},{"text":" which will always return a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" with the same fixed size no matter what was recorded.","type":"text"}],"title":"FixedSizeRecvByteBufferAllocator","kind":"symbol","role":"symbol","type":"topic","url":"\/documentation\/niocore\/fixedsizerecvbytebufferallocator","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"FixedSizeRecvByteBufferAllocator"}],"navigatorTitle":[{"kind":"identifier","text":"FixedSizeRecvByteBufferAllocator"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/RecvAllocatorOption":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/RecvAllocatorOption","title":"ChannelOptions.Types.RecvAllocatorOption","navigatorTitle":[{"kind":"identifier","text":"RecvAllocatorOption"}],"type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/recvallocatoroption","role":"symbol","abstract":[{"code":"RecvAllocatorOption","type":"codeVoice"},{"type":"text","text":" allows users to specify the "},{"code":"RecvByteBufferAllocator","type":"codeVoice"},{"type":"text","text":" to use."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"RecvAllocatorOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoop":{"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EventLoop","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoop","type":"topic","navigatorTitle":[{"text":"EventLoop","kind":"identifier"}],"title":"EventLoop","role":"symbol","url":"\/documentation\/niocore\/eventloop","abstract":[{"text":"An EventLoop processes IO \/ tasks in an endless loop for ","type":"text"},{"code":"Channel","type":"codeVoice"},{"type":"text","text":"s until itâ€™s closed."}]},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLCustomPrivateKey":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLCustomPrivateKey","kind":"identifier"}],"navigatorTitle":[{"text":"NIOSSLCustomPrivateKey","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niossl\/niosslcustomprivatekey","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey"},{"text":" defines the interface of a custom, non-BoringSSL private key.","type":"text"}],"title":"NIOSSLCustomPrivateKey","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/AllocatorOption":{"role":"symbol","navigatorTitle":[{"text":"AllocatorOption","kind":"identifier"}],"abstract":[{"type":"codeVoice","code":"AllocatorOption"},{"text":" allows to specify the ","type":"text"},{"type":"codeVoice","code":"ByteBufferAllocator"},{"text":" to use.","type":"text"}],"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AllocatorOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/allocatoroption","kind":"symbol","title":"ChannelOptions.Types.AllocatorOption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/AllocatorOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/BacklogOption":{"navigatorTitle":[{"kind":"identifier","text":"BacklogOption"}],"url":"\/documentation\/niocore\/channeloptions\/types\/backlogoption","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/BacklogOption","abstract":[{"code":"BacklogOption","type":"codeVoice"},{"type":"text","text":" allows users to configure the "},{"code":"backlog","type":"codeVoice"},{"type":"text","text":" value as specified in "},{"code":"man 2 listen","type":"codeVoice"},{"type":"text","text":". This is only useful for "},{"code":"ServerSocketChannel","type":"codeVoice"},{"type":"text","text":"s."}],"title":"ChannelOptions.Types.BacklogOption","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"BacklogOption"}],"type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/SocketOption":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SocketOption","kind":"identifier"}],"url":"\/documentation\/niocore\/channeloptions\/types\/socketoption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/SocketOption","abstract":[{"type":"codeVoice","code":"SocketOption"},{"text":" allows users to specify configuration settings that are directly applied to the underlying socket file descriptor.","type":"text"}],"type":"topic","title":"ChannelOptions.Types.SocketOption","role":"symbol","navigatorTitle":[{"text":"SocketOption","kind":"identifier"}],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/Channel":{"url":"\/documentation\/niocore\/channel","navigatorTitle":[{"kind":"identifier","text":"Channel"}],"title":"Channel","role":"symbol","abstract":[{"type":"text","text":"A "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" is easiest thought of as a network socket. But it can be anything that is capable of I\/O operations such"},{"type":"text","text":" "},{"type":"text","text":"as read, write, connect, and bind."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Channel","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Channel"}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions/Types/DatagramVectorReadMessageCountOption":{"abstract":[{"code":"DatagramVectorReadMessageCountOption","type":"codeVoice"},{"text":" allows users to configure the number of messages to attempt to read in a single syscall on a","type":"text"},{"text":" ","type":"text"},{"text":"datagram ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":".","type":"text"}],"title":"ChannelOptions.Types.DatagramVectorReadMessageCountOption","type":"topic","url":"\/documentation\/niocore\/channeloptions\/types\/datagramvectorreadmessagecountoption","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions\/Types\/DatagramVectorReadMessageCountOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","role":"collection","kind":"symbol","type":"topic","abstract":[],"title":"NIOCore","url":"\/documentation\/niocore"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPreconcurrencySendable":{"title":"NIOPreconcurrencySendable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","kind":"symbol","abstract":[],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"url":"\/documentation\/niocore\/niopreconcurrencysendable","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOEmbedded/EmbeddedEventLoop":{"navigatorTitle":[{"text":"EmbeddedEventLoop","kind":"identifier"}],"url":"\/documentation\/nioembedded\/embeddedeventloop","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOEmbedded\/EmbeddedEventLoop","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"EmbeddedEventLoop","kind":"identifier"}],"title":"EmbeddedEventLoop","type":"topic","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"An "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" that is embedded in the current running context with no external"},{"type":"text","text":" "},{"type":"text","text":"control."}]}}}